// UUID Generator Extension
// Version 1.0
// Made by Toxic5018
// Follow my website: https://toxic5018.github.io/toxic5018.me/

(async function (Scratch) {
    if (!Scratch.extensions.unsandboxed) {
        alert("This extension needs to be unsandboxed to use the UUID Generator functions!");
        return;
    }

    // --- Extension Configuration ---
    const mainColor = "#333333"; // Dark grey
    const gradientColor = "#222222"; // Even darker grey for gradient
    const blockIcon = "https://github.com/toxic5018/T4Extension/blob/main/assets/block8.png?raw=true";
    const menuIcon = "https://github.com/toxic5018/T4Extension/blob/main/assets/uuidgenerator_extension_logo.png?raw=true";

    // --- Internal State & Utilities ---
    let lastGeneratedUUID = null; // Stores the last UUID generated by any block
    let lastGeneratedUUIDVersion = null; // Stores the version of the last generated UUID

    // Event Emitter for Hat Blocks
    const fireEvent = (eventName, detail = {}) => {
        Scratch.vm.runtime.emit(eventName, detail);
    };

    // --- UUID Generation Functions ---

    // UUID v4: Randomly generated UUID
    function generateUUIDv4() {
        const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
        lastGeneratedUUID = uuid;
        lastGeneratedUUIDVersion = 4;
        fireEvent('UUID_GENERATED', { uuid: uuid, version: 4 });
        // Removed fireEvent('UUID_VERSION_GENERATED', { uuid: uuid, version: 4 });
        return uuid;
    }

    // Helper for UUID v1 (time-based)
    // This is a simplified implementation. Real UUID v1 requires a stable node ID (MAC address)
    // and a clock sequence that is persistent and increments on clock resets.
    // For a browser extension, we use a pseudo-random node and a random clock sequence per session.
    let _nodeId = null;
    let _clockSequence = null;
    let _lastTimestamp = null;
    const GREGORIAN_CALENDAR_START = 122192928000000000n; // 1582-10-15 00:00:00 UTC in 100-nanosecond intervals

    function generateUUIDv1() {
        if (_nodeId === null) {
            // Generate a random 48-bit node ID, set multicast bit (LSB of first byte is 1)
            _nodeId = Array.from({ length: 6 }, () => Math.floor(Math.random() * 256));
            _nodeId[0] |= 0x01; // Set multicast bit
        }
        if (_clockSequence === null) {
            _clockSequence = Math.floor(Math.random() * 0x4000); // 14-bit random clock sequence
        }

        let timestamp = BigInt(Date.now()) * 10000n + GREGORIAN_CALENDAR_START; // Current time in 100-nanosecond intervals

        // Handle clock sequence increment if time goes backwards or is the same (unlikely in browsers)
        if (_lastTimestamp !== null && timestamp <= _lastTimestamp) {
            _clockSequence = (_clockSequence + 1) & 0x3FFF; // Increment and wrap 14-bit
        }
        _lastTimestamp = timestamp;

        // Convert timestamp to 60-bit (low, mid, high bits)
        const tl = (timestamp & 0xFFFFFFFFn);
        const tm = (timestamp >> 32n) & 0xFFFFn;
        const th = (timestamp >> 48n) & 0x0FFFn;

        const timeLow = tl.toString(16).padStart(8, '0');
        const timeMid = tm.toString(16).padStart(4, '0');
        const timeHighAndVersion = (th | 0x1000n).toString(16).padStart(4, '0'); // Version 1

        const clockSeqHighAndRes = ((_clockSequence >> 8) | 0x80).toString(16); // Variant 1 (0x80) and high 6 bits of clock seq
        const clockSeqLow = (_clockSequence & 0xFF).toString(16).padStart(2, '0');

        const nodeIdHex = _nodeId.map(b => b.toString(16).padStart(2, '0')).join('');

        const uuid = `${timeLow}-${timeMid}-${timeHighAndVersion}-${clockSeqHighAndRes}${clockSeqLow}-${nodeIdHex}`;

        lastGeneratedUUID = uuid;
        lastGeneratedUUIDVersion = 1;
        fireEvent('UUID_GENERATED', { uuid: uuid, version: 1 });
        // Removed fireEvent('UUID_VERSION_GENERATED', { uuid: uuid, version: 1 });
        return uuid;
    }

    // Helper for UUID v3/v5: Name-based UUIDs using MD5/SHA-1 hashing.
    // Requires Crypto.subtle for hashing.
    async function _generateNameUUID(namespaceUUID, name, version) {
        if (!crypto || !crypto.subtle || !crypto.subtle.digest) {
            console.error("Web Crypto API not available for UUID v3/v5 generation.");
            return "";
        }

        try {
            // Validate namespace UUID
            if (!isValidUUID(namespaceUUID)) {
                console.warn("Invalid namespace UUID provided for name-based UUID generation.");
                return "";
            }

            // Convert namespace UUID to bytes
            const nsBytes = uuidToBytes(namespaceUUID);
            const nameBytes = new TextEncoder().encode(name);

            // Concatenate namespace bytes and name bytes
            const data = new Uint8Array(nsBytes.length + nameBytes.length);
            data.set(nsBytes);
            data.set(nameBytes, nsBytes.length);

            const algorithm = version === 3 ? 'MD5' : 'SHA-1';
            const hashBuffer = await crypto.subtle.digest(algorithm, data);
            const hashBytes = new Uint8Array(hashBuffer);

            // Apply UUID version and variant bits
            let bytes = Array.from(hashBytes.slice(0, 16));
            bytes[6] = (bytes[6] & 0x0F) | (version << 4); // Version bits
            bytes[8] = (bytes[8] & 0x3F) | 0x80; // Variant bits (set to 10xx for RFC 4122)

            const uuid = bytesToUuid(bytes);

            lastGeneratedUUID = uuid;
            lastGeneratedUUIDVersion = version;
            fireEvent('UUID_GENERATED', { uuid: uuid, version: version });
            // Removed fireEvent('UUID_VERSION_GENERATED', { uuid: uuid, version: version });
            return uuid;
        } catch (e) {
            console.error(`Error generating UUID v${version}:`, e);
            return "";
        }
    }

    // Helper to convert UUID string to byte array
    function uuidToBytes(uuid) {
        const hex = uuid.replace(/-/g, '');
        const bytes = new Uint8Array(16);
        for (let i = 0; i < 16; i++) {
            bytes[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
        }
        return bytes;
    }

    // Helper to convert byte array to UUID string
    function bytesToUuid(bytes) {
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20, 32)}`;
    }

    async function generateUUIDv3(args) {
        return await _generateNameUUID(String(args.NAMESPACE_UUID), String(args.NAME), 3);
    }

    async function generateUUIDv5(args) {
        return await _generateNameUUID(String(args.NAMESPACE_UUID), String(args.NAME), 5);
    }

    function generateMultipleUUIDs(args) {
        const count = Math.max(0, Math.min(1000, Number(args.COUNT))); // Limit to 1000 for performance
        const uuids = [];
        for (let i = 0; i < count; i++) {
            uuids.push(generateUUIDv4()); // Default to v4 for multiple
        }
        return JSON.stringify(uuids);
    }

    // --- UUID Data & Validation ---

    function isValidUUID(uuidString) {
        const regex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
        return regex.test(uuidString);
    }

    function getUUIDVersion(args) {
        const uuidString = String(args.UUID);
        if (!isValidUUID(uuidString)) return -1; // Invalid UUID

        const versionByte = parseInt(uuidString[14], 16); // The 4th nibble of the 6th byte
        return (versionByte & 0xF0) >> 4; // Extract version nibble
    }

    function getUUIDVariant(args) {
        const uuidString = String(args.UUID);
        if (!isValidUUID(uuidString)) return -1;

        const variantByte = parseInt(uuidString[19], 16); // The 1st nibble of the 8th byte
        // RFC 4122 variant:
        // 0xxx = NCS backward compatibility (reserved)
        // 10xx = RFC 4122 (this is what we expect)
        // 110x = Microsoft backward compatibility (reserved)
        // 111x = Future definition (reserved)
        if ((variantByte & 0xC0) === 0x80) return 1; // RFC 4122
        if ((variantByte & 0xE0) === 0xC0) return 2; // Microsoft
        if ((variantByte & 0xE0) === 0xE0) return 3; // Future
        return 0; // NCS
    }

    function getUUIDTimestamp(args) {
        const uuidString = String(args.UUID);
        if (!isValidUUID(uuidString)) return "";
        if (getUUIDVersion(args) !== 1) return ""; // Only for v1 UUIDs

        // Extract time fields from v1 UUID string
        const timeLow = BigInt('0x' + uuidString.substring(0, 8));
        const timeMid = BigInt('0x' + uuidString.substring(9, 13));
        const timeHigh = BigInt('0x' + uuidString.substring(14, 18)) & 0x0FFFn; // Mask out version bits

        const timestamp100ns = (timeHigh << 48n) | (timeMid << 32n) | timeLow;
        const unixTimestampMs = Number((timestamp100ns - GREGORIAN_CALENDAR_START) / 10000n);

        return unixTimestampMs; // Return as milliseconds since Unix epoch
    }

    function getUUIDNode(args) {
        const uuidString = String(args.UUID);
        if (!isValidUUID(uuidString)) return "";
        if (getUUIDVersion(args) !== 1) return ""; // Only for v1 UUIDs

        // Node ID is the last 12 characters (6 bytes)
        return uuidString.substring(24);
    }

    function parseUUID(args) {
        const uuidString = String(args.UUID);
        if (!isValidUUID(uuidString)) {
            return JSON.stringify({ error: "Invalid UUID" });
        }

        const version = getUUIDVersion(args);
        const variant = getUUIDVariant(args);

        const parsed = {
            uuid: uuidString,
            version: version,
            variant: variant,
            parts: {
                time_low: uuidString.substring(0, 8),
                time_mid: uuidString.substring(9, 13),
                time_high_and_version: uuidString.substring(14, 18),
                clock_seq_and_variant: uuidString.substring(19, 23),
                node: uuidString.substring(24, 36)
            }
        };

        if (version === 1) {
            parsed.timestamp_ms = getUUIDTimestamp(args);
            parsed.node_id = getUUIDNode(args);
        }
        // Add more parsing for other versions if needed

        return JSON.stringify(parsed);
    }

    // --- New Blocks for specific UUID parts and well-known namespaces ---

    // Function to get specific parts of a UUID string
    function getUUIDPart(args) {
        const uuidString = String(args.UUID_STRING);
        const partName = String(args.PART_NAME);

        if (!isValidUUID(uuidString)) return "";

        switch (partName) {
            case "time_low": return uuidString.substring(0, 8);
            case "time_mid": return uuidString.substring(9, 13);
            case "time_high_and_version": return uuidString.substring(14, 18);
            case "clock_seq_and_variant": return uuidString.substring(19, 23);
            case "node": return uuidString.substring(24, 36);
            default: return "";
        }
    }

    // Well-known Namespace UUIDs (from RFC 4122, Appendix C)
    const DNS_NAMESPACE_UUID = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    const URL_NAMESPACE_UUID = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    const OID_NAMESPACE_UUID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
    const X500_NAMESPACE_UUID = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";


    class UUIDGeneratorExtension {
        constructor(runtime) {
            this.runtime = runtime;
        }

        getInfo() {
            return {
                id: "toxic5018UUIDGenerator",
                name: "UUID Generator",
                color1: mainColor,
                color2: gradientColor,
                menuIconURI: menuIcon,
                blocks: [
                    {
                        opcode: "extensionVersion",
                        blockType: Scratch.BlockType.LABEL,
                        text: "Version 1.0",
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    "---",
                    {
                        opcode: "labelSimpleUUID",
                        blockType: Scratch.BlockType.LABEL,
                        text: "-- UUID Generator (Simple) --",
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "generateUUIDv4Block",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "generate random UUID (v4)",
                        func: "generateUUIDv4Block",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    "---",
                    {
                        opcode: "labelAdvancedUUID",
                        blockType: Scratch.BlockType.LABEL,
                        text: "-- UUID Generator (Advanced) --",
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "generateUUIDv1Block",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "generate time-based UUID (v1)",
                        func: "generateUUIDv1Block",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "generateUUIDv3Block",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "generate name-based UUID (v3 MD5) namespace [NAMESPACE_UUID] name [NAME]",
                        arguments: {
                            NAMESPACE_UUID: { type: Scratch.ArgumentType.STRING, defaultValue: DNS_NAMESPACE_UUID },
                            NAME: { type: Scratch.ArgumentType.STRING, defaultValue: "example.com" },
                        },
                        func: "generateUUIDv3Block",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "generateUUIDv5Block",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "generate name-based UUID (v5 SHA1) namespace [NAMESPACE_UUID] name [NAME]",
                        arguments: {
                            NAMESPACE_UUID: { type: Scratch.ArgumentType.STRING, defaultValue: DNS_NAMESPACE_UUID },
                            NAME: { type: Scratch.ArgumentType.STRING, defaultValue: "example.org" },
                        },
                        func: "generateUUIDv5Block",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "generateMultipleUUIDsBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "generate [COUNT] UUIDs (JSON array)",
                        arguments: {
                            COUNT: { type: Scratch.ArgumentType.NUMBER, defaultValue: 5 },
                        },
                        func: "generateMultipleUUIDsBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    "---",
                    {
                        opcode: "labelUUIDData",
                        blockType: Scratch.BlockType.LABEL,
                        text: "-- UUID Data --",
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "isValidUUIDBlock",
                        blockType: Scratch.BlockType.BOOLEAN,
                        text: "[UUID_STRING] is a valid UUID?",
                        arguments: {
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-7890-1234-567890abcdef" },
                        },
                        func: "isValidUUIDBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getUUIDVersionBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "version of UUID [UUID_STRING]",
                        arguments: {
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-7890-1234-567890abcdef" },
                        },
                        func: "getUUIDVersionBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getUUIDVariantBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "variant of UUID [UUID_STRING]",
                        arguments: {
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-7890-1234-567890abcdef" },
                        },
                        func: "getUUIDVariantBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getUUIDTimestampBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "timestamp (ms) of UUID [UUID_STRING] (v1 only)",
                        arguments: {
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-11e5-80b4-00c04fd430c8" },
                        },
                        func: "getUUIDTimestampBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getUUIDNodeBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "node ID of UUID [UUID_STRING] (v1 only)",
                        arguments: {
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-11e5-80b4-00c04fd430c8" },
                        },
                        func: "getUUIDNodeBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "parseUUIDBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "parse UUID [UUID_STRING] (JSON)",
                        arguments: {
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-7890-1234-567890abcdef" },
                        },
                        func: "parseUUIDBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    // New blocks for well-known namespace UUIDs
                    {
                        opcode: "getDNSNamespaceUUID",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "DNS Namespace UUID",
                        func: "getDNSNamespaceUUID",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getURLNamespaceUUID",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "URL Namespace UUID",
                        func: "getURLNamespaceUUID",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getOIDNamespaceUUID",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "OID Namespace UUID",
                        func: "getOIDNamespaceUUID",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "getX500NamespaceUUID",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "X.500 Namespace UUID",
                        func: "getX500NamespaceUUID",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    // New block for getting specific UUID parts
                    {
                        opcode: "getUUIDPartBlock",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "get [PART_NAME] of UUID [UUID_STRING]",
                        arguments: {
                            PART_NAME: {
                                type: Scratch.ArgumentType.STRING,
                                menu: "uuidPartsMenu"
                            },
                            UUID_STRING: { type: Scratch.ArgumentType.STRING, defaultValue: "a1b2c3d4-e5f6-7890-1234-567890abcdef" },
                        },
                        func: "getUUIDPartBlock",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    "---",
                    {
                        opcode: "labelUUIDStatus",
                        blockType: Scratch.BlockType.LABEL,
                        text: "-- UUID Status --",
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    // Hat Blocks (correctly defined as HAT type)
                    {
                        opcode: "whenNewUUIDGenerated",
                        blockType: Scratch.BlockType.HAT,
                        text: "when new UUID is generated",
                        isEdgeActivated: false,
                        func: "whenNewUUIDGenerated",
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    // Removed the "when UUID version [VERSION] is generated" hat block
                    // Reporter Blocks for Status (must be used as inputs)
                    {
                        opcode: "lastGeneratedUUID",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "last generated UUID",
                        func: "lastGeneratedUUID",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "lastGeneratedUUIDVersion",
                        blockType: Scratch.BlockType.REPORTER,
                        text: "version of last generated UUID",
                        func: "lastGeneratedUUIDVersion",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                    {
                        opcode: "isLastGeneratedUUIDValid",
                        blockType: Scratch.BlockType.BOOLEAN,
                        text: "is last generated UUID valid?",
                        func: "isLastGeneratedUUIDValid",
                        blockIconURI: blockIcon,
                        color1: mainColor,
                        color2: gradientColor,
                    },
                ],
                menus: {
                    uuidPartsMenu: {
                        acceptReporters: true,
                        items: [
                            { text: "time low", value: "time_low" },
                            { text: "time mid", value: "time_mid" },
                            { text: "time high and version", value: "time_high_and_version" },
                            { text: "clock sequence and variant", value: "clock_seq_and_variant" },
                            { text: "node", value: "node" }
                        ]
                    }
                },
            };
        }

        // --- Hat Block Handlers ---
        whenNewUUIDGenerated() { return true; }
        // Removed whenUUIDVersionIs handler

        // --- Bind Functions to Extension ---
        generateUUIDv4Block() { return generateUUIDv4(); }
        async generateUUIDv1Block() { return await generateUUIDv1(); }
        async generateUUIDv3Block(args) { return await generateUUIDv3(args); }
        async generateUUIDv5Block(args) { return await generateUUIDv5(args); }
        generateMultipleUUIDsBlock(args) { return generateMultipleUUIDs(args); }

        isValidUUIDBlock(args) { return isValidUUID(args.UUID_STRING); }
        getUUIDVersionBlock(args) { return getUUIDVersion(args); }
        getUUIDVariantBlock(args) { return getUUIDVariant(args); }
        getUUIDTimestampBlock(args) { return getUUIDTimestamp(args); }
        getUUIDNodeBlock(args) { return getUUIDNode(args); }
        parseUUIDBlock(args) { return parseUUID(args); }

        // New blocks for well-known namespace UUIDs
        getDNSNamespaceUUID() { return DNS_NAMESPACE_UUID; }
        getURLNamespaceUUID() { return URL_NAMESPACE_UUID; }
        getOIDNamespaceUUID() { return OID_NAMESPACE_UUID; }
        getX500NamespaceUUID() { return X500_NAMESPACE_UUID; }

        // New block for getting specific UUID parts
        getUUIDPartBlock(args) { return getUUIDPart(args); }

        lastGeneratedUUID() { return lastGeneratedUUID || ""; }
        lastGeneratedUUIDVersion() { return lastGeneratedUUIDVersion || -1; }
        isLastGeneratedUUIDValid() { return isValidUUID(lastGeneratedUUID || ""); }
    }

    Scratch.extensions.register(new UUIDGeneratorExtension());
})(Scratch);